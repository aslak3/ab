/* Address Book
 * by Lawrence Manning 
 *
 * filename: event.c
 */

#include "ab.h"
#include "externals.h"

extern struct arexx_command_type arexx_commands[];

/* This bit handles the control of the main window. */
void main_window_events(void)
{
    /* General event variables. */
    LONG quit_program = NOT_QUITTING;
    ULONG arexx_port_signal_mask, commodity_port_signal_mask;
    ULONG main_window_signal_mask;
    ULONG combined_signal_mask;
    ULONG received_signals;
    /* These variables are used by the ARexx command processer. */
    struct RexxMsg *arexx_message;
    UBYTE *end_of_command;
    LONG end_of_command_position;
    UBYTE arexx_command_line[GENERAL_STRING_SIZE];
    UBYTE arexx_command[GENERAL_STRING_SIZE];
    UBYTE arexx_arguments[GENERAL_STRING_SIZE];
    LONG arexx_action;
    LONG arexx_result1;
    UBYTE arexx_result2[GENERAL_STRING_SIZE];
    /* These variables are used by the commodity handler. */
    CxMsg *commodity_message;
    ULONG message_id, message_type;
    /* These variables are used by the IDCMP handler for the main window. */
    struct IntuiMessage *imessage;
    ULONG message_class; UWORD message_code; APTR message_address;
    UWORD message_qualifier;
    struct Gadget *gadget_address;
    UWORD gadgetid;
    UBYTE keypress;
    UWORD selection_number;
    UWORD menu_number, item_number, subitem_number;
    struct MenuItem *item_address;

    /* Work out the signal mask for the window and the arexx port.  Then make
     * a combined mask. */
    arexx_port_signal_mask = 1L << (arexx_port->mp_SigBit);
    commodity_port_signal_mask = 1L << (commodity_port->mp_SigBit);

    while (quit_program != NORMAL_QUIT && quit_program != NO_CONFIRMATION_QUIT)
    {
        /* First see if main window is open and adjust signal mask. */
        if (main_window)
            main_window_signal_mask = 1L << (main_window->UserPort->mp_SigBit);
        else
            main_window_signal_mask = 0;

        combined_signal_mask = arexx_port_signal_mask | commodity_port_signal_mask |
            main_window_signal_mask | SIGBREAKF_CTRL_C | SIGBREAKF_CTRL_F;
            
        /* Wait for something interesting to happen. */
        received_signals = Wait(combined_signal_mask);

        /* See if the mesage was generated by the ARexx port. */
        if (received_signals & arexx_port_signal_mask)
        {
            while (arexx_message = (struct RexxMsg *) GetMsg(arexx_port))
            {
                strcpy(arexx_command_line, arexx_message->rm_Args[0]);

                /* See if command line contains a space.  This indicates that
                 * there are some arguments. */
                if (end_of_command = strchr(arexx_command_line, ' '))
                {
                    /* This bit of code finds the space character, and
                     * copies the command to another string variable.
                     * then it fetches the argument, copying from the
                     * the charecter after the space. */
                    end_of_command_position = end_of_command - arexx_command_line;
                    strncpy(arexx_command, arexx_command_line, end_of_command_position);
                    arexx_command[end_of_command_position] = '\0';
                    strcpy(arexx_arguments, arexx_command_line +
                         end_of_command_position + 1);
                }
                else
                {
                    /* No arguments specified, so simply copy the command
                     * across, and make the arguments string blank. */
                    strcpy(arexx_command, arexx_command_line);
                    strcpy(arexx_arguments, "");
                }

                arexx_action = arexx_message->rm_Action;

                /* Reset result variables. */
                arexx_result1 = RC_OK;
                strcpy(arexx_result2, "");

                /* Now call the arexx command handler with the command
                 * parameters worked out above. */
                quit_program = main_window_arexx(arexx_command, arexx_arguments,
                    arexx_action, &arexx_result1, arexx_result2);

                /* Now set result1 and result2 in the message structure
                 * according to the outcome of the command performed. */
                arexx_message->rm_Result1 = arexx_result1;
                if (strlen(arexx_result2))
                {
                    arexx_message->rm_Result2 = (LONG) CreateArgstring
                        (arexx_result2, strlen(arexx_result2));
                }

                /* Only now can we reply to the message. */
                ReplyMsg((struct Message *) arexx_message);
            }
        }

        /* See if the signal was generated by commodites. */
        if (received_signals & commodity_port_signal_mask)
        {
            while (commodity_message = (CxMsg *) GetMsg(commodity_port))
            {
                /* Get message details. */
                message_id = CxMsgID(commodity_message);
                message_type = CxMsgType(commodity_message);

                /* We can now send it back to the sender. */
                ReplyMsg((struct Message *) commodity_message);

                /* Check to see that the message is a command message. */
                if (message_type == CXM_COMMAND)
                    quit_program = main_window_commodity(message_id);
            }
        }

        /* See if the signal was generated by an IDCMP message. */
        if (received_signals & main_window_signal_mask)
        {
            while (imessage = GT_GetIMsg(main_window->UserPort))
            {
                /* Copy the message class and code fields so we can reply
                 * right away. */
                message_class = imessage->Class;
                message_code = imessage->Code;
                message_address = imessage->IAddress;
                message_qualifier = imessage->Qualifier;

                GT_ReplyIMsg(imessage);

                /* See what job needs to be done. */
                switch (message_class)
                {
                    case IDCMP_CLOSEWINDOW:
                        make_hidden = TRUE;
                        break;

                    case IDCMP_GADGETDOWN:
                    case IDCMP_GADGETUP:
                    case IDCMP_MOUSEMOVE:
                        gadget_address = (struct Gadget *) message_address;
                        gadgetid = gadget_address->GadgetID;
                        quit_program = main_window_gadgets(message_class, gadgetid,
                            message_code);
                        break;

                    case IDCMP_VANILLAKEY:
                        keypress = toupper((UBYTE) message_code);
                        quit_program = main_window_vanilla_keypress(keypress,
                            message_qualifier);
                        break;

                    case IDCMP_RAWKEY:
                        keypress = (UBYTE) message_code;
                        quit_program = main_window_raw_keypress(keypress,
                            message_qualifier);
                        break;

                    case IDCMP_MENUPICK:
                        /* Make an internal copy of the menu number. */
                        selection_number = message_code;

                        /* Keep going until there are no more menu picks. */
                        while (selection_number != MENUNULL)
                        {
                            /* Compute the menu, item, and subitem. */
                            menu_number = MENUNUM(selection_number);
                            item_number = ITEMNUM(selection_number);
                            subitem_number = SUBNUM(selection_number);

                            quit_program = main_window_menus(menu_number, item_number,
                                subitem_number);

                            /* Find the item address of this selection. */
                            item_address = ItemAddress(main_window_menu,
                               selection_number);

                            /* Find the next selected menu if there is one. */
                            selection_number = item_address->NextSelect;
                        }
                        break;

                    case IDCMP_REFRESHWINDOW:
                        /* Simply call the start and end refresh functions. */
                        GT_BeginRefresh(main_window);
                        GT_EndRefresh(main_window, TRUE);

                    default:
                        break;
                }
            }
        }

        /* This handles the quit signal. */
        if (received_signals & SIGBREAKF_CTRL_C)
            quit_program = NORMAL_QUIT;

        /* This handles the show window signal.  You can make this hapen either
         * by pressing the hotkey, or by sending it with the Break command. */
        if (received_signals & SIGBREAKF_CTRL_F)
            make_shown = TRUE;

        /* This bit of codes acts as a check for program quiting.  If
         * changes have been made to the project (without them being saved)
         * then a requester will popup giving the user the option not
         * to quit.  This requester is by-passed if quit_program is equal to
         * NO_CONFIRM_QUIT. */
        if (quit_program == NORMAL_QUIT && project_changed)
        {
            if (message_requester("Changes made to project will\n"
                "be lost if you quit now. Quit\n"
                "anyway?", TRUE))
            {
                quit_program = NORMAL_QUIT;
            }
            else
                quit_program = NOT_QUITTING;
        }

        /* Deal with Hide/Show function. */
        if (make_hidden)
        {
            hide_ab();
            make_hidden = FALSE;
        }

        if (make_shown)
        {
            show_ab();
            make_shown = FALSE;
        }

    } /* End exit program loop.  Return to main(). */               
}

/* This big function procces ARexx commands.  It normally returns NOT_QUITTING,
 * but if the user issued the QUIT command, then one of two things will be
 * returned.  Specifing QUIT (no args) will return NORMAL_QUIT.  Specifing
 * QUIT NO_CONFIRM will return NO_CONFIRM, by-passing the confirmation requester
 * that appears if changes are un-saved. */
LONG main_window_arexx(UBYTE *arexx_command, UBYTE *arexx_arguments,
    LONG arexx_action, LONG *arexx_result1, UBYTE *arexx_result2)
{
    BOOL close_window = FALSE;
    BOOL no_confirmation = FALSE;
    BOOL command_valid = FALSE;
    LONG command_count = 0;
    LONG result1;
    UBYTE result2[GENERAL_STRING_SIZE];

    /* First make sure command is actualy a command for AB. */
    if ((arexx_action & RXCODEMASK) == RXCOMM)
    {
        /* Check for quit command.  Note that this command is delt with
         * differently from the others. */
        if (strcmp(arexx_command, "QUIT") == 0)
        {
            command_valid = TRUE;
            close_window = TRUE;

            if (strcmp(arexx_arguments, "NO_CONFIRM") == 0)
                no_confirmation = TRUE;

            result1 = RC_OK;
            strcpy(result2, "");
        }

        /* Check for all other ARexx commands by looking through the command
         * list. */
        while (arexx_commands[command_count].arexx_command_name != NULL)
        {
            /* If a command matches, the call it using its function hook. */
            if (strcmp(arexx_command,
                arexx_commands[command_count].arexx_command_name) == 0)
            {
                command_valid = TRUE;
                (*arexx_commands[command_count].arexx_command_function)
                    (&result1, result2, arexx_arguments);
            }
            command_count++;
        }

        /* See if command is invalid.  If so, set result1 accordingly. */
        if (command_valid == FALSE)
        {
            result1 = RC_FATAL;
            strcpy(result2, "");
        }
    }

    /* Copy the result1 variable across, and if we need too, copy result2
     * to the result variable in main_window_events. */
    *arexx_result1 = result1;
    if (arexx_action & RXFF_RESULT)
        strcpy(arexx_result2, result2);

    /* Now we need to find out what we should return.  This depends on
     * close_window and no_confirm BOOLs */
    if (close_window)
        if (no_confirmation)
            return (NO_CONFIRMATION_QUIT);
        else
            return (NORMAL_QUIT);
    else
        return (NOT_QUITTING);
}

/* This function handles commodity messages.  Returns NORMAL_QUIT if the user
 * selected to remove from the Exchange program. */
LONG main_window_commodity(ULONG message_id)
{
    BOOL close_window = FALSE;

    switch (message_id)
    {
        /* Ignore these for now. */
        case CXCMD_DISABLE:
            break;

        case CXCMD_ENABLE:
            break;

        /* You can make AB quit from Exchange. */
        case CXCMD_KILL:
            close_window = TRUE;
            break;

        /* Or make it appear... */
        case CXCMD_APPEAR:
            make_shown = TRUE;
            break;

        /* ...or make it disappar. */
        case CXCMD_DISAPPEAR:
            make_hidden = TRUE;
            break;

        /* This happens if we try to run two AB's. */
        case CXCMD_UNIQUE:
            make_shown = TRUE;
            break;

        default:
            break;
    }

    if (close_window)
        return (NORMAL_QUIT);
    else
        return (NOT_QUITTING);
}

/* This function handles the gadgets in the main window.  Returns TRUE if
 * the user selected a gadget which quits the program. */
LONG main_window_gadgets(ULONG message_class, UWORD gadgetid,
    UWORD message_code)
{
    BOOL close_window = FALSE;

    switch (message_class)
    {
        /* This case is for gadget down (immediate) messages.  If we get one
         * of these then it is ignored. */
        case IDCMP_GADGETDOWN:
            break;

        /* This is the most common occurance, the user has released a gadget
         * but which one? */
        case IDCMP_GADGETUP:
        {
            switch (gadgetid)
            {
                /* The user has pressed and released on the movement scroller.
                 * This happens if either he clicks outside the knob, or he
                 * has finished dragging the thing about.  Update the display,
                 * and the buttons (including the scroller itself). */
                case GADID_MOVEMENT_SCROLLER:
                    goto_any_entry((LONG) message_code + 1, TRUE);
                    break;

                /* Normal button press. */
                case GADID_EDIT_BUTTON:
                    edit_entry();
                    break;

                case GADID_NEW_BUTTON:
                    new_entry();
                    break;

                case GADID_DELETE_BUTTON:
                    delete_entry();
                    break;

                case GADID_DIAL_BUTTON:
                    dial_entry();
                    break;

                default:
                    break;
            }
            break;
        }

        /* I got a mouse movement message.  We only get these if the user is
         * playing with the movement scroller. */
        case IDCMP_MOUSEMOVE:
        {
            switch (gadgetid)
            {
                /* When user is moving the scroller, we do not update the
                 * buttons, only the entry display. */
                case GADID_MOVEMENT_SCROLLER:
                    goto_any_entry((LONG) message_code + 1, FALSE);
                    break;

                default:
                    break;
            }
        }

        default:
            break;
    }

    if (close_window)
        return (NORMAL_QUIT);
    else
        return (NOT_QUITTING);
}

/* This function deals with vanilla keyboard shortcuts.  Returns NORMAL_QUIT if
 * the user pressed a key to quit. */
LONG main_window_vanilla_keypress(UBYTE keypress, UWORD message_qualifier)
{
    BOOL close_window = FALSE;

    switch (keypress)
    {
        /* Buttons. */
        case 'E':
            edit_entry();
            break;

        case 'N':
            new_entry();
            break;

        case 'D':
            delete_entry();
            break;

        case 'I':
            dial_entry();
            break;

        default:
            break;
    }

    if (close_window)
        return (NORMAL_QUIT);
    else
        return (NOT_QUITTING);
}

/* This function deals with raw keypress occurances.  Presently only the cursor
 * keys are acted upon.  Future versions might use the Help key to caal up the
 * AmigaGuide help. */
LONG main_window_raw_keypress(UBYTE keypress, UWORD message_qualifier)
{
    BOOL close_window = FALSE;

    switch (keypress)
    {
        /* Movement shortcuts. */
        case CURSORLEFT:
            if (!(message_qualifier & SHIFT_QUALIFIER))
                goto_prev_entry();
            else
                goto_first_entry();
            break;

        case CURSORRIGHT:
            if (!(message_qualifier & SHIFT_QUALIFIER))
                goto_next_entry();
            else
                goto_last_entry();
            break;
    }

    if (close_window)
        return (NORMAL_QUIT);
    else
        return (NOT_QUITTING);
}

/* This function deals with the menus in the main window.  Returns NORMAL_QUIT
 * if the user selected Quit from the Project menu. */
LONG main_window_menus(UWORD menu_number, UWORD item_number, 
    UWORD subitem_number)
{
    BOOL close_window = FALSE;

    switch (menu_number)
    {
        /* Project menu. */
        case MENUID_PROJECT:
            switch (item_number)
            {
                case MENUID_NEW:
                    new_project();
                    break;
  
                case MENUID_OPEN:
                    open_project();
                    break;
 
                case MENUID_SAVE:
                    save_project();
                    break;

                case MENUID_SAVE_AS:
                    save_as_project();
                    break;

                case MENUID_PRINT:
                    print_project();
                    break;

                case MENUID_ABOUT:
                    show_about_requester();
                    break;

                case MENUID_HIDE:
                    make_hidden = TRUE;
                    break;

                case MENUID_QUIT:
                    close_window = TRUE;
                    break;

                default:
                    break;
            }
            break;

        /* Edit menu. */
        case MENUID_EDIT:
            switch (item_number)
            {
                case MENUID_SEARCH:
                    search_entries();
                    break;

                case MENUID_SEARCH_AGAIN:
                    search_entries_again();
                    break;

                default:
                    break;
            }
            break;

        case MENUID_SETTINGS:
            switch (item_number)
            {
                case MENUID_PRINT_HEADERS:
                    settings.print_headers = MENU_CHECKBOX(main_window_menu,
                        MENUID_SETTINGS, MENUID_PRINT_HEADERS, NOSUB);
                    break;

                case MENUID_PRINT_ALL:
                    settings.print_all = MENU_CHECKBOX(main_window_menu,
                        MENUID_SETTINGS, MENUID_PRINT_ALL, NOSUB);
                    break;

                case MENUID_SAVE_SETTINGS:
                    save_settings();
                    break;

                default:
                    break;
            }
            break;

        /* Unknown menu number. */
        default:
            break;
    }

    if (close_window)
        return (NORMAL_QUIT);
    else
        return (NOT_QUITTING);
}
        
/* This routine handles the processing of events for the edit window. */
void edit_window_events(void)
{
    struct IntuiMessage *imessage = NULL;
    BOOL close_window = FALSE;
    ULONG edit_window_signal_mask;
    ULONG message_class; UWORD message_code; APTR message_address;
    UWORD message_qualifier;
    struct Gadget *gadget_address;
    UWORD gadgetid;
    UBYTE keypress;

    /* Work out the signal mask for the window, based on the window's message
     * port, then make a combined mask. */
    edit_window_signal_mask = 1L << (edit_window->UserPort->mp_SigBit);

    while (!close_window)
    {
        /* Wait for something interesting to happen. */
        Wait(edit_window_signal_mask);

        while (imessage = GT_GetIMsg(edit_window->UserPort))
        {
            /* Copy the message class and code fields so we can reply
             * right away. */
            message_class = imessage->Class;
            message_code = imessage->Code;
            message_address = imessage->IAddress;
            message_qualifier = imessage->Qualifier;

            GT_ReplyIMsg(imessage);

            /* See what job needs to be done. */
            switch (message_class)
            {
                case IDCMP_CLOSEWINDOW:
                    close_window = TRUE;
                    edit_window_result = EDIT_WINDOW_RESULT_CANCEL;
                    break;

                case IDCMP_GADGETUP:
                    gadget_address = (struct Gadget *) message_address;
                    gadgetid = gadget_address->GadgetID;
                    close_window = edit_window_gadgets(message_class, gadgetid,
                        message_code);
                    break;

                case IDCMP_VANILLAKEY:
                    keypress = toupper((UBYTE) message_code);
                    close_window = edit_window_keypress(keypress,
                        message_qualifier);
                    break;

                case IDCMP_ACTIVEWINDOW:
                    ActivateGadget(edit_window_gadget_list[GADID_NAME_STRING],
                        edit_window, NULL);
                    break;

                case IDCMP_REFRESHWINDOW:
                    /* Simply call the start and end refresh functions. */
                    GT_BeginRefresh(edit_window);
                    GT_EndRefresh(edit_window, TRUE);

                default:
                    break;
            }
        }

        /* We reset close_window to FALSE if edit_window_result is
         * EDIT_WINDOW_RESULT_OK and the name gadget is empty.  We also
         * show an error requester. */
        if (close_window && edit_window_result == EDIT_WINDOW_RESULT_OK &&
            strlen_gadget(edit_window_gadget_list[GADID_NAME_STRING]) == 0)
        {
            close_window = FALSE;
            message_requester("Please enter a name for\nthis entry to proceed.", FALSE);
        }

    } /* End exit window loop. */ 
}

/* This function handles the gadgets in the edit window.  Returns TRUE if user
 * selected a gadget that should close the window, FALSE othewise. */
BOOL edit_window_gadgets(ULONG message_class, UWORD gadgetid,
    UWORD message_code)
{
    BOOL close_window = FALSE;
    LONG activate_gadget;

    switch (gadgetid)
    {
        case GADID_NAME_STRING:
        case GADID_ADDRESS_ONE_STRING:
        case GADID_ADDRESS_TWO_STRING:
        case GADID_ADDRESS_THREE_STRING:
        case GADID_ADDRESS_FOUR_STRING:
        case GADID_ADDRESS_FIVE_STRING:
        case GADID_PHONE_STRING:
        case GADID_EMAIL_STRING:
            activate_gadget = (LONG) edit_window_gadget_list[gadgetid]->UserData;
            ActivateGadget(edit_window_gadget_list[activate_gadget], edit_window, NULL);
            break;
            
        case GADID_OK_BUTTON:
            edit_window_result = EDIT_WINDOW_RESULT_OK;
            close_window = TRUE;
            break;

        case GADID_CANCEL_BUTTON:
            edit_window_result = EDIT_WINDOW_RESULT_CANCEL;
            close_window = TRUE;
            break;

        default:
            break;
    }

    return (close_window);
}

/* This is the keyboard handler for the edit window.  Returns TRUE if the user
 * clicked on a button which should close the window (this may be overridden
 * later though, if there is no name for this entry). */
BOOL edit_window_keypress(UBYTE keypress, UWORD message_qualifier)
{
    BOOL close_window = FALSE;

    switch (keypress)
    {
        /* Ok button. */
        case 'O':
            edit_window_result = EDIT_WINDOW_RESULT_OK;
            close_window = TRUE;
            break;

        /* Cancel button. */
        case 'C':
            edit_window_result = EDIT_WINDOW_RESULT_CANCEL;
            close_window = TRUE;
            break;

        default:
            break;
    }

    return (close_window);
}

/* This routine handles the processing of events for the string window. */
void string_window_events(void)
{
    struct IntuiMessage *imessage = NULL;
    BOOL close_window = FALSE;
    ULONG string_window_signal_mask;
    ULONG message_class; UWORD message_code; APTR message_address;
    UWORD message_qualifier;
    struct Gadget *gadget_address;
    UWORD gadgetid;
    UBYTE keypress;

    /* Work out the signal mask for the window, based on the window's message
     * port, then make a combined mask. */
    string_window_signal_mask = 1L << (string_window->UserPort->mp_SigBit);

    while (!close_window)
    {
        /* Wait for something interesting to happen. */
        Wait(string_window_signal_mask);

        while (imessage = GT_GetIMsg(string_window->UserPort))
        {
            /* Copy the message class and code fields so we can reply
             * right away. */
            message_class = imessage->Class;
            message_code = imessage->Code;
            message_address = imessage->IAddress;
            message_qualifier = imessage->Qualifier;

            GT_ReplyIMsg(imessage);

            /* See what job needs to be done. */
            switch (message_class)
            {
                case IDCMP_CLOSEWINDOW:
                    close_window = TRUE;
                    string_window_result = STRING_WINDOW_RESULT_CANCEL;
                    break;

                case IDCMP_GADGETUP:
                    gadget_address = (struct Gadget *) message_address;
                    gadgetid = gadget_address->GadgetID;
                    close_window = string_window_gadgets(message_class, gadgetid,
                        message_code);
                    break;

                case IDCMP_VANILLAKEY:
                    keypress = toupper((UBYTE) message_code);
                    close_window = string_window_keypress(keypress, message_qualifier);
                    break;

                case IDCMP_ACTIVEWINDOW:
                    ActivateGadget(string_window_gadget_list[GADID_STRING_STRING],
                        string_window, NULL);
                    break;

                case IDCMP_REFRESHWINDOW:
                    /* Simply call the start and end refresh functions. */
                    GT_BeginRefresh(string_window);
                    GT_EndRefresh(string_window, TRUE);

                default:
                    break;
            }
        }

        /* We reset close_window to FALSE if edit_window_result is
         * EDIT_WINDOW_RESULT_OK and the name gadget is empty.  We also
         * show an error requester. */
        if (close_window && string_window_result == STRING_WINDOW_RESULT_OK &&
            !strlen_gadget(string_window_gadget_list[GADID_STRING_STRING]))
        {
            close_window = FALSE;
            message_requester("Please enter a search\nentry to proceed.", FALSE);
        }

    } /* End exit window loop. */               
}

/* This function handles the gadgets in the string window.  Returns TRUE if user
 * selected a gadget that should close the window, FALSE othewise. */
BOOL string_window_gadgets(ULONG message_class, UWORD gadgetid,
    UWORD message_code)
{
    BOOL close_window = FALSE;

    switch (gadgetid)
    {
        case GADID_TYPE_CYCLE:
            /* Update the current search type if the user presses the cycle
             * gadget. */
            current_search_type = message_code;
            break;

        /* No need to do anything here. */
        case GADID_STRING_STRING:
            break;

        case GADID_OK2_BUTTON:
            string_window_result = STRING_WINDOW_RESULT_OK;
            close_window = TRUE;
            break;

        case GADID_CANCEL2_BUTTON:
            string_window_result = STRING_WINDOW_RESULT_CANCEL;
            close_window = TRUE;
            break;

        default:
            break;
    }

    return (close_window);
}

/* This is the keyboard handler for the string window.  Functions in a simular
 * way to the gadget handler for this window.  Returns TRUE if the user clicked
 * on a button which should close the window (this may be overridden later
 * though, if there is no search entry). */
BOOL string_window_keypress(UBYTE keypress, UWORD message_qualifier)
{
    BOOL close_window = FALSE;

    switch (keypress)
    {
        /* Search type cycle gadget. */
        case 'S':
            /* No shift key pressed, so cycle forward. */
            if (!(message_qualifier & SHIFT_QUALIFIER))
            {
                current_search_type += 1;
                if (current_search_type == 3)
                    current_search_type = 0;
            }
            /* Otherwise, the shift key was pressed, so cycle backwards. */
            else
            {
                current_search_type -= 1;
                if (current_search_type == -1)
                    current_search_type = 2;
            }

            /* Now update the gadget display for the new setting. */
            GT_SetGadgetAttrs(string_window_gadget_list[GADID_TYPE_CYCLE],
                string_window, NULL, GTCY_Active, current_search_type - 1,
                TAG_DONE);
            break;

        /* Ok button. */
        case 'O':
            string_window_result = STRING_WINDOW_RESULT_OK;
            close_window = TRUE;
            break;

        /* Cancel button. */
        case 'C':
            string_window_result = STRING_WINDOW_RESULT_CANCEL;
            close_window = TRUE;
            break;

        default:
            break;
    }

    return (close_window);
}
